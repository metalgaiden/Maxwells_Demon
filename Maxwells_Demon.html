<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>Maxwell's Demon Simulation</title>
		<style>
			body { margin: 0; }
			canvas { display: block; }
		</style>
	</head>
	<body>
		<script src="three.js/build/three.js"></script>
		<script>
			// Our Javascript will go here.
			var scene = new THREE.Scene();
			var camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
			var renderer = new THREE.WebGLRenderer();
			renderer.setSize(window.innerWidth, window.innerHeight);
			document.body.appendChild(renderer.domElement);

			const hemiLight = new THREE.HemisphereLight();
			hemiLight.intensity = 0.35;
			scene.add( hemiLight );

			const dirLight = new THREE.DirectionalLight();
			dirLight.position.set( 5, 5, 5 );
			dirLight.castShadow = true;
			dirLight.shadow.camera.zoom = 2;
			scene.add( dirLight );


			// variables for the box size
			var depth = 4;
			var width = 20;
			var height = 10;
			var middleWallPos = 4;

			// door variable
			var doorMove = 0;

			//walls material: 
			var material01 = new THREE.MeshNormalMaterial();

			// geometry 1 (left wall and right wall)
			var geometry01 = new THREE.BoxGeometry(1, height, depth);
			// geometry 2 (top and bottom walls)
			var geometry02 = new THREE.BoxGeometry(width, 1, depth);
			// geometry 3 for middle walls
			var geometry03 = new THREE.BoxGeometry(1, height/3, depth);
			// geometry 4 for the door
			var geometry04 = new THREE.BoxGeometry(1, height/3+1, depth);


			// a cube has geometric and material properties
			var cube01 = new THREE.Mesh(geometry01, material01);
			var cube02 = new THREE.Mesh(geometry02, material01);
			var cube03 = new THREE.Mesh(geometry01, material01);
			var cube04 = new THREE.Mesh(geometry02, material01);
			var cube05 = new THREE.Mesh(geometry03, material01);
			var cube06 = new THREE.Mesh(geometry03, material01);
			var cube07 = new THREE.Mesh(geometry04, material01); // door

			// setting position of all of the walls / door
			cube01.position.set( -(width/2), 0, 0);
			cube02.position.set( 0, (height/2), 0);
			cube03.position.set((width/2), 0, 0);
			cube04.position.set( 0, -(height/2), 0);
			cube05.position.set( middleWallPos, height/3, 0);
			cube06.position.set( middleWallPos, -height/3, 0);
			cube07.position.set( middleWallPos, 0, 0);

			// adding walls to the scene
			scene.add(cube01);
			scene.add(cube02);
			scene.add(cube03);
			scene.add(cube04);
			scene.add(cube05);
			scene.add(cube06);
			scene.add(cube07);
			camera.position.z = 15; // this moves the camera towards the user 5 units


			function MouseDown(event) {
				console.log('MouseDown');
				doorMove = 0.02;
			}

			function MouseUp(event) {
				console.log('MouseUp');
				doorMove = -0.02;
			}

			document.addEventListener('mousedown', MouseDown, false);
			document.addEventListener('mouseup', MouseUp, false);


			// Physics
			const material = new THREE.MeshLambertMaterial();
			const matrix = new THREE.Matrix4();
			const color = new THREE.Color();
			// Spheres
			const geometrySphere = new THREE.IcosahedronBufferGeometry( 0.3, 3 );
			spheres = new THREE.InstancedMesh( geometrySphere, material, 50 );
			spheres.castShadow = true;
			spheres.receiveShadow = true;
			scene.add( spheres );

			let position = [];
			let velocity = [];
			for ( let i = 0; i < spheres.count; i ++ ) {
				position[i] = new THREE.Vector3( Math.random() * 6 - 4, Math.random() * 5 - 2, 0.0);
				velocity[i] = new THREE.Vector3( (Math.random() - 0.5)*0.05, (Math.random() - 0.5)*0.05, 0.0 );
				matrix.setPosition(position[i]);
				spheres.setMatrixAt( i, matrix );
				spheres.setColorAt( i, color.setHex( 0xffffff * Math.random() ) );
			}
			
			function animate(){
				for ( let i = 0; i < spheres.count; i ++ ) {
					for ( let j = 0; j < spheres.count; j ++ ) {
						if (i != j){
							let distance = position[i].distanceTo(position[j]);
							if (distance < 0.6){
								let vi = velocity[i].clone();
								let vj = velocity[j].clone();
								let pi = position[i].clone();
								let pj = position[j].clone();
								position[i].lerp(position[j], -(1/(100*distance)));
								velocity[i] = velocity[j];
								velocity[j] = vi;
							}
						}
					}
					if (position[i].y >= 4){
						velocity[i].y = Math.abs(velocity[i].y) * -1;
					}if (position[i].y <= -4){
						velocity[i].y = Math.abs(velocity[i].y);
					}
					if (position[i].x >= 3){
						velocity[i].x = Math.abs(velocity[i].x) * -1;
					}if (position[i].x <= -9){
						velocity[i].x = Math.abs(velocity[i].x);
					}
					position[i].x += velocity[i].x;
					position[i].y += velocity[i].y;
	 
					matrix.setPosition(position[i]);
					spheres.setMatrixAt( i, matrix );
					spheres.setColorAt( i, color.setHex( 0xffffff * Math.random() ) );
				}
				spheres.instanceMatrix.needsUpdate = true;

				if (cube07.position.y < 0){
					doorMove = 0;
					cube07.position.y = 0;
				}
				if (cube07.position.y > 4){
					doorMove = 0;
					cube07.position.y = 4;
				}

				cube07.position.y += doorMove;

				requestAnimationFrame(animate);
				renderer.render(scene, camera);

			}

			animate();


		</script>
	</body>
</html>
