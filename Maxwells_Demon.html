<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>Maxwell's Demon Simulation</title>
		<style>
			body { margin: 0; }
			canvas { display: block; }
		</style>
	</head>
	<body>
		<script src="three.js/build/three.js"></script>
		<script>
			// Our Javascript will go here.
			var scene = new THREE.Scene();
			var camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
			var renderer = new THREE.WebGLRenderer();
			renderer.setSize(window.innerWidth, window.innerHeight);
			document.body.appendChild(renderer.domElement);

			const hemiLight = new THREE.HemisphereLight();
			hemiLight.intensity = 0.35;
			scene.add( hemiLight );

			const dirLight = new THREE.DirectionalLight();
			dirLight.position.set( 5, 5, 5 );
			dirLight.castShadow = true;
			dirLight.shadow.camera.zoom = 2;
			scene.add( dirLight );


			// variables for the box size
			var depth = 4;
			var width = 20;
			var height = 10;
			var middleWallPos = 4;

			// door variable
			var doorMove = 0;

			//walls material: 
			var material01 = new THREE.MeshNormalMaterial();

			// geometry 1 (left wall and right wall)
			var geometry01 = new THREE.BoxGeometry(1, height, depth);
			// geometry 2 (top and bottom walls)
			var geometry02 = new THREE.BoxGeometry(width, 1, depth);
			// geometry 3 for middle walls
			var geometry03 = new THREE.BoxGeometry(1, height/3, depth);
			// geometry 4 for the door
			var geometry04 = new THREE.BoxGeometry(1, height/3+1, depth);


			// a cube has geometric and material properties
			var cube01 = new THREE.Mesh(geometry01, material01);
			var cube02 = new THREE.Mesh(geometry02, material01);
			var cube03 = new THREE.Mesh(geometry01, material01);
			var cube04 = new THREE.Mesh(geometry02, material01);
			var cube05 = new THREE.Mesh(geometry03, material01);
			var cube06 = new THREE.Mesh(geometry03, material01);
			var cube07 = new THREE.Mesh(geometry04, material01); // door

			// setting position of all of the walls / door
			cube01.position.set( -(width/2), 0, 0);
			cube02.position.set( 0, (height/2), 0);
			cube03.position.set((width/2), 0, 0);
			cube04.position.set( 0, -(height/2), 0);
			cube05.position.set( middleWallPos, height/3, 0);
			cube06.position.set( middleWallPos, -height/3, 0);
			cube07.position.set( middleWallPos, 0, 0);

			// adding walls to the scene
			scene.add(cube01);
			scene.add(cube02);
			scene.add(cube03);
			scene.add(cube04);
			scene.add(cube05);
			scene.add(cube06);
			scene.add(cube07);
			camera.position.z = 15; // this moves the camera towards the user 5 units


			function MouseDown(event) {
				console.log('MouseDown');
				doorMove = 0.02;
			}

			function MouseUp(event) {
				console.log('MouseUp');
				doorMove = -0.02;
			}

			document.addEventListener('mousedown', MouseDown, false);
			document.addEventListener('mouseup', MouseUp, false);


			// Physics
			const material = new THREE.MeshLambertMaterial();
			const matrix = new THREE.Matrix4();
			const color = new THREE.Color();
			// Spheres
			const geometrySphere = new THREE.IcosahedronBufferGeometry( 0.075, 3 );
			spheres = new THREE.InstancedMesh( geometrySphere, material, 100 );
			spheres.castShadow = true;
			spheres.receiveShadow = true;
			scene.add( spheres );

			let position = [];
			let velocity = [];
			for ( let i = 0; i < spheres.count; i ++ ) {
				position[i] = new THREE.Vector3( Math.random() - 0.5, Math.random() * 2, Math.random() - 0.5 );
				velocity[i] = new THREE.Vector3( (Math.random() - 0.5)*0.1, (Math.random() - 0.5)*0.1, 0.0 );
				matrix.setPosition(position[i]);
				spheres.setMatrixAt( i, matrix );
				spheres.setColorAt( i, color.setHex( 0xffffff * Math.random() ) );
			}
			let j = 0;
			
			function animate(){
				for ( let i = 0; i < spheres.count; i ++ ) {
					if (position[i].y >= 4 || position[i].y <= -4){
						velocity[i].y = velocity[i].y * -1;
					}
					if (position[i].x >= 3 || position[i].x <= -9){
						velocity[i].x = velocity[i].x * -1;
					}
					position[i].x += velocity[i].x;
					position[i].y += velocity[i].y;
	 
					matrix.setPosition(position[i]);
					spheres.setMatrixAt( i, matrix );
					spheres.setColorAt( i, color.setHex( 0xffffff * Math.random() ) );
				}
				spheres.instanceMatrix.needsUpdate = true;

				if (cube07.position.y < 0){
					doorMove = 0;
					cube07.position.y = 0;
				}
				if (cube07.position.y > 4){
					doorMove = 0;
					cube07.position.y = 4;
				}

				cube07.position.y += doorMove;

				requestAnimationFrame(animate);
				renderer.render(scene, camera);

			}

			animate();


		</script>
	</body>
</html>
